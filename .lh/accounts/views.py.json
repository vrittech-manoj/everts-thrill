{
    "sourceFile": "accounts/views.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1725344503184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725344519763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,10 +55,8 @@\n     filterset_fields = {\n         'email': ['exact', 'icontains'],\n         'username': ['exact'],\n         'role': ['exact'],\n-\n-        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n         'is_active':['exact'],\n     }\n \n     permission_classes = [AccountPermission]\n"
                },
                {
                    "date": 1725344603560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,8 @@\n     ordering_fields = ['username','id']\n     filterset_fields = {\n         'email': ['exact', 'icontains'],\n         'username': ['exact'],\n-        'role': ['exact'],\n         'is_active':['exact'],\n     }\n \n     permission_classes = [AccountPermission]\n@@ -407,9 +406,8 @@\n         if apple_token == False:\n             return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n         \n         idinfo,is_verify = VerifyAppleToken(apple_token)\n-        print(idinfo)\n         if idinfo:\n             user,success_user = createAppleAccount(idinfo)\n         else:\n             return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n"
                },
                {
                    "date": 1725344616419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -400,36 +400,32 @@\n \n class AppleLogin(APIView):\n     @csrf_exempt\n     def post(self, request):\n-    \n+\n         apple_token = request.data.get('idToken',False)\n         if apple_token == False:\n             return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n-        \n+\n         idinfo,is_verify = VerifyAppleToken(apple_token)\n         if idinfo:\n             user,success_user = createAppleAccount(idinfo)\n         else:\n             return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n-   \n-        # If the user is authenticated, log them in and generate tokens\n-        if success_user == True:\n-            if user.is_active == False:\n-                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n-            # login(request, user)\n-            refresh = RefreshToken.for_user(user)\n-            user_obj = CustomUserSerializer(user,context={'request': request}) \n-            return Response({\n-                'access': str(refresh.access_token),\n-                'refresh': str(refresh),\n-                'user': user_obj.data,\n-                'message': 'Login successful',\n-            }, status=status.HTTP_200_OK)\n \n-        # If the user is not authenticated, return an error message\n-        else:\n+        if success_user != True:\n             return Response({'error': 'Apple Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n+        if user.is_active == False:\n+            return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n+        # login(request, user)\n+        refresh = RefreshToken.for_user(user)\n+        user_obj = CustomUserSerializer(user,context={'request': request})\n+        return Response({\n+            'access': str(refresh.access_token),\n+            'refresh': str(refresh),\n+            'user': user_obj.data,\n+            'message': 'Login successful',\n+        }, status=status.HTTP_200_OK)\n \n \n def createAppleAccount(idinfo):\n     email = idinfo.get('email')\n"
                },
                {
                    "date": 1725344629508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -392,13 +392,13 @@\n     image = idinfo.get('picture')\n     user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n     if user.exists():\n         user = user.first()\n-        return user,True\n-    else:    \n+    else:\n         user = CustomUser.objects.create(email = email , first_name = first_name , last_name = last_name, username=username,role = 5,old_password_change_case = False,provider = 2,is_verified = True)\n-        return user , True\n \n+    return user,True\n+\n class AppleLogin(APIView):\n     @csrf_exempt\n     def post(self, request):\n \n"
                },
                {
                    "date": 1725344639418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,444 @@\n+from django.db.models import Q\n+from django.contrib.auth import authenticate, login\n+from django.views.decorators.csrf import csrf_exempt\n+from django.contrib.auth.models import Group, Permission\n+from django.http import HttpResponse\n+from django_filters.rest_framework import DjangoFilterBackend\n+\n+from rest_framework import status, viewsets\n+from rest_framework.views import APIView\n+from rest_framework.response import Response\n+from rest_framework.permissions import IsAuthenticated\n+from rest_framework.filters import SearchFilter, OrderingFilter\n+from rest_framework_simplejwt.authentication import JWTAuthentication\n+from rest_framework_simplejwt.tokens import RefreshToken,TokenError\n+from rest_framework_simplejwt.tokens import AccessToken\n+from rest_framework.exceptions import PermissionDenied\n+from rest_framework import generics\n+from rest_framework.decorators import action\n+\n+from drf_yasg import openapi\n+from drf_yasg.utils import swagger_auto_schema\n+\n+from .models import CustomUser\n+\n+from . import roles\n+from .roles import roles_data\n+\n+from accounts.serializers.custom_user_serializers import LoginSerializer\n+from accounts.serializers.custom_user_serializers import (\n+    CustomUserReadSerializer,CustomUserSerializer, GroupSerializer, \n+    PermissionSerializer,RoleSerializer,CustomUserReadLimitedSerializer,\n+    UserDetailsSerializer,CustomUserReadLimitedSerializer_1\n+    )\n+\n+from .custompermission import AccountPermission,AllUserDataPermission\n+from .pagination import PageNumberPagination\n+\n+from .google_virify import VerifyGoogleToken\n+from .apple_verify import VerifyAppleToken\n+\n+from django.core.cache import cache\n+from django.views.decorators.cache import cache_page\n+from django.utils.decorators import method_decorator\n+cache_time = 300 # 300 is 5 minute\n+from django.db.models import Q\n+from rest_framework import serializers\n+\n+class CustomUserSerializerViewSet(viewsets.ModelViewSet):\n+    queryset = CustomUser.objects.all()\n+    # permission_classes = [Account]\n+    serializer_class = CustomUserReadSerializer\n+    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n+    search_fields = ['id','email','username','first_name']\n+    ordering_fields = ['username','id']\n+    filterset_fields = {\n+        'email': ['exact', 'icontains'],\n+        'username': ['exact'],\n+        'is_active':['exact'],\n+    }\n+\n+    permission_classes = [AccountPermission]\n+    \n+    def get_serializer_class(self):\n+        if self.action in ['create', 'update', 'partial_update']:\n+            return CustomUserSerializer\n+        return super().get_serializer_class()\n+    \n+    def get_queryset(self):\n+        user = self.request.user\n+        queryset = CustomUser.objects.all().order_by('-id')\n+        \n+        if not user.is_authenticated:\n+            query = CustomUser.objects.none()\n+        elif user.role == roles.SUPER_ADMIN:\n+            query = queryset\n+        elif user.role == roles.ADMIN:\n+            query = queryset.filter(id=user.id, role=roles.ADMIN)\n+        else:\n+            query = queryset.filter(id=user.id, is_active=True)\n+        \n+        return query.order_by(\"-created_date\")\n+    \n+    \n+    \n+    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n+    def list(self, request, *args, **kwargs):\n+        queryset = self.filter_queryset(self.get_queryset())\n+        serializer = self.get_serializer(queryset, many=True)\n+        data = serializer.data\n+        return Response(data)\n+\n+    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n+    def retrieve(self, request, *args, **kwargs):\n+        return super().retrieve(request, *args, **kwargs)\n+\n+    def destroy(self, request, *args, **kwargs):\n+        instance = self.get_object()\n+\n+        if instance.is_active:\n+            # If the user is active, mark them as inactive\n+        \n+            instance.is_active = False\n+            instance.delete= \"delete\"\n+            instance.save()\n+            # Create a custom response\n+            response_data = {\n+                \"message\": \"User Account marked as inactive\"\n+            }\n+        else:\n+            # If the user is already inactive, return a custom error response\n+            response_data = {\n+                \"message\": \"User Account is already inactive\"\n+            }\n+\n+        # Return the custom response\n+        return Response(response_data)\n+    \n+    def create(self, request, *args, **kwargs):\n+        serializer = self.get_serializer(data=request.data)\n+        serializer.is_valid(raise_exception=True)\n+\n+        # Save the new object to the database\n+        self.perform_create(serializer)\n+\n+    \n+        response_data = {\n+            \"message\": \"Account created successfully\",\n+            \"data\": serializer.data\n+        }\n+\n+            # Return the custom response\n+        return Response(response_data, status=status.HTTP_201_CREATED)\n+    \n+class RoleViewSet(APIView):\n+    # authentication_classes = [JWTAuthentication]\n+    # permission_classes = [IsAuthenticated]  \n+    \n+    def get(self,request,format=None):\n+        serializer = RoleSerializer(data=roles_data,many=True)\n+        serializer.is_valid()\n+        serialized_data = serializer.data\n+    \n+        return Response({\"roles\": serialized_data},status=status.HTTP_200_OK)\n+\n+\n+class GroupViewSet(viewsets.ModelViewSet):\n+    queryset = Group.objects.all()\n+    serializer_class = GroupSerializer\n+    filter_backends = [SearchFilter]\n+    search_fields = ['name']\n+    authentication_classes = [JWTAuthentication]\n+    permission_classes = [IsAuthenticated]    \n+    def create(self, request, *args, **kwargs):\n+        serializer = self.get_serializer(data=request.data)\n+        serializer.is_valid(raise_exception=True)\n+\n+        # Save the new object to the database\n+        self.perform_create(serializer)\n+\n+        # Create a custom response\n+        response_data = {\n+            \"message\": \"Group created successfully\",\n+            \"data\": serializer.data\n+        }\n+\n+        # Return the custom response\n+        return Response(response_data, status=status.HTTP_201_CREATED)\n+    \n+    def update(self, request, *args, **kwargs):\n+        partial = kwargs.pop('partial', False)\n+        instance = self.get_object()\n+        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n+        serializer.is_valid(raise_exception=True)\n+\n+        # Save the updated object to the database\n+        self.perform_update(serializer)\n+\n+        # Create a custom response\n+        response_data = {\n+            \"message\": \"Group updated successfully\",\n+            \"data\": serializer.data\n+        }\n+\n+        # Return the custom response\n+        return Response(response_data)\n+    \n+    def destroy(self, request, *args, **kwargs):\n+        instance = self.get_object()\n+\n+        # Perform the default delete logic\n+        self.perform_destroy(instance)\n+\n+        # Create a custom response\n+        response_data = {\n+            \"message\": \"Group deleted successfully\"\n+        }\n+\n+        # Return the custom response\n+        return Response(response_data)\n+\n+    \n+class PermissionViewSet(viewsets.ModelViewSet):\n+    queryset = Permission.objects.all()\n+    serializer_class = PermissionSerializer\n+    filter_backends = [SearchFilter,OrderingFilter]\n+    search_fields = ['name','code_name','is_verified']\n+    ordering_fields = ['id','name']\n+\n+    authentication_classes = [JWTAuthentication]\n+    permission_classes = [IsAuthenticated]    \n+\n+class PermissionAllDelete(APIView):\n+    authentication_classes = [JWTAuthentication]\n+    permission_classes = [IsAuthenticated]  \n+    def get(self, request, format=None):\n+        object = Permission.objects.all().delete()\n+        return Response({'message': 'All permission delete successful'}, status=status.HTTP_200_OK)\n+\n+class CheckTokenExpireView(APIView): \n+    def get(self, request, format=None):\n+        # Get the token from the request headers or query parameters\n+        try:\n+            raw_token = request.META.get('HTTP_AUTHORIZATION', '').split(' ')[1]\n+        except:\n+            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+        try:\n+            # Verify the access token\n+            access_token = AccessToken(raw_token)\n+            access_token.verify()\n+\n+            # If the token is valid and not expired\n+            return Response({'valid': True}, status=status.HTTP_200_OK)\n+\n+        except TokenError:\n+            # If the token is expired or invalid\n+            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+# Create your views here.\n+class LoginView(APIView):\n+    @swagger_auto_schema(\n+        request_body=openapi.Schema(\n+            type=openapi.TYPE_OBJECT,\n+            properties={\n+                'email': openapi.Schema(type=openapi.TYPE_STRING),\n+                'password': openapi.Schema(type=openapi.TYPE_STRING),\n+            },\n+            required=['email', 'password']\n+        ),\n+        # responses={200: MyResponseSerializer},\n+        operation_summary=\"Login and get token\",\n+        operation_description=\"Login and get token\",\n+    )\n+    # @csrf_exempt\n+    def post(self, request):\n+        username_or_email = request.data.get('email')\n+        password = request.data.get('password')\n+\n+        # Authenticate the user using either username or email\n+        user = authenticate(request, username=username_or_email, password=password)\n+        if user is None:\n+            user = authenticate(request, email=username_or_email, password=password)\n+\n+        # If the user is authenticated, log them in and generate tokens\n+        if user is not None:\n+            if user.is_active == False:\n+                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n+            login(request, user)\n+            refresh = RefreshToken.for_user(user)\n+            refresh['remember_me'] = request.data.get('remember_me',False)\n+            user_obj = CustomUserReadSerializer(request.user,context={'request': request}) \n+            return Response({\n+                'access': str(refresh.access_token),\n+                'refresh': str(refresh),\n+                'user': user_obj.data,\n+                'message': 'Login successful',\n+            }, status=status.HTTP_200_OK)\n+\n+        # If the user is not authenticated, return an error message\n+        else:\n+            from django.db.models import Q\n+            user_obj = CustomUser.objects.filter(Q(username=username_or_email) | Q(email=username_or_email))\n+            if user_obj.exists():\n+                return Response({'error': 'Invalid password'}, status=status.HTTP_401_UNAUTHORIZED)\n+            else:\n+                return Response({'error': 'Invalid username/email'}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+\n+class userLimitedData(generics.ListAPIView):\n+    # authentication_classes = [JWTAuthentication]\n+    # permission_classes = [IsAuthenticated]\n+\n+\n+    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n+    search_fields = ['id','email','username','first_name','last_name','phone']\n+    ordering_fields = ['username','id']\n+    filterset_fields = {\n+        'email': ['exact', 'icontains'],\n+        'username': ['exact'],\n+        'role': ['exact'],\n+        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n+        'is_active':['exact'],\n+    }\n+    \n+    def get_queryset(self):\n+        users = CustomUser.objects.filter(role = roles.USER,is_active = True)\n+        return users\n+\n+    def get_serializer_class(self):\n+        return CustomUserReadLimitedSerializer\n+    \n+    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n+    def list(self, request, *args, **kwargs):\n+        return super().list(request, *args, **kwargs)\n+\n+\n+class AllUserData(generics.ListAPIView):\n+    authentication_classes = [JWTAuthentication]\n+    permission_classes = [IsAuthenticated,] #AllUserDataPermission\n+    pagination_class =  PageNumberPagination\n+\n+    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n+    search_fields = ['id','email','username','first_name','last_name','phone']\n+    ordering_fields = ['username','id']\n+    filterset_fields = {\n+        'email': ['exact', 'icontains'],\n+        'username': ['exact'],\n+        'role': ['exact'],\n+        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n+        'is_active':['exact'],\n+    }\n+    \n+    def get_queryset(self):\n+        users = CustomUser.objects.all().order_by('id')\n+        return users\n+\n+    def get_serializer_class(self):\n+        return CustomUserReadLimitedSerializer_1\n+    \n+    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n+    def list(self, request, *args, **kwargs):\n+        return super().list(request, *args, **kwargs)\n+\n+\n+class UserDetailsView(generics.RetrieveAPIView):\n+    queryset = CustomUser.objects.all()\n+    serializer_class = UserDetailsSerializer\n+    authentication_classes = [JWTAuthentication]\n+    lookup_field = \"username\"\n+    # permission_classes = [IsAuthenticated]\n+\n+\n+class GoogleLogin(APIView):\n+    @csrf_exempt\n+    def post(self, request):\n+    \n+        google_id_token = request.data.get('idToken',False)\n+\n+        if google_id_token == False:\n+            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n+     \n+        idinfo,is_verify = VerifyGoogleToken(google_id_token)\n+       \n+        if idinfo:\n+            user,success_user = createGoogleAccount(idinfo)\n+        else:\n+            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n+   \n+        # If the user is authenticated, log them in and generate tokens\n+        if success_user == True:\n+            if user.is_active == False:\n+                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n+            # login(request, user)\n+            refresh = RefreshToken.for_user(user)\n+            user_obj = CustomUserSerializer(user,context={'request': request}) \n+            return Response({\n+                'access': str(refresh.access_token),\n+                'refresh': str(refresh),\n+                'user': user_obj.data,\n+                'message': 'Login successful',\n+            }, status=status.HTTP_200_OK)\n+\n+        # If the user is not authenticated, return an error message\n+        else:\n+            return Response({'error': 'Google Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n+        \n+def createGoogleAccount(idinfo):\n+    email = idinfo.get('email')\n+    first_name = idinfo.get('name')\n+    last_name = idinfo.get('family_name')\n+    username = email.split('@')[0]\n+    image = idinfo.get('picture')\n+    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n+    if user.exists():\n+        user = user.first()\n+        return user,True\n+    else:    \n+        user = CustomUser.objects.create(email = email , first_name = first_name , last_name = last_name, username=username,role = 5,old_password_change_case = False,provider = 2,is_verified = True)\n+        return user , True\n+\n+class AppleLogin(APIView):\n+    @csrf_exempt\n+    def post(self, request):\n+\n+        apple_token = request.data.get('idToken',False)\n+        if apple_token == False:\n+            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n+\n+        idinfo,is_verify = VerifyAppleToken(apple_token)\n+        if idinfo:\n+            user,success_user = createAppleAccount(idinfo)\n+        else:\n+            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+        if success_user != True:\n+            return Response({'error': 'Apple Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n+        if user.is_active == False:\n+            return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n+        # login(request, user)\n+        refresh = RefreshToken.for_user(user)\n+        user_obj = CustomUserSerializer(user,context={'request': request})\n+        return Response({\n+            'access': str(refresh.access_token),\n+            'refresh': str(refresh),\n+            'user': user_obj.data,\n+            'message': 'Login successful',\n+        }, status=status.HTTP_200_OK)\n+\n+\n+def createAppleAccount(idinfo):\n+    email = idinfo.get('email')\n+    if not email:\n+        raise serializers.ValidationError('Email address not provided.')\n+    username = email.split('@')[0]\n+    first_name = idinfo.get('full_name',username)\n+    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n+    if user.exists():\n+        user = CustomUser.objects.get(Q(email = email) | Q(username = username))\n+    else:    \n+        user = CustomUser.objects.create(email = email,is_verified = True , first_name = first_name, username=username,role = 5,old_password_change_case = False,provider = 4)\n+    return user , True\n+   \n+\n+\n"
                },
                {
                    "date": 1725344656762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -392,452 +392,8 @@\n     image = idinfo.get('picture')\n     user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n     if user.exists():\n         user = user.first()\n-        return user,True\n-    else:    \n-        user = CustomUser.objects.create(email = email , first_name = first_name , last_name = last_name, username=username,role = 5,old_password_change_case = False,provider = 2,is_verified = True)\n-        return user , True\n-\n-class AppleLogin(APIView):\n-    @csrf_exempt\n-    def post(self, request):\n-\n-        apple_token = request.data.get('idToken',False)\n-        if apple_token == False:\n-            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n-\n-        idinfo,is_verify = VerifyAppleToken(apple_token)\n-        if idinfo:\n-            user,success_user = createAppleAccount(idinfo)\n-        else:\n-            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-        if success_user != True:\n-            return Response({'error': 'Apple Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n-        if user.is_active == False:\n-            return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n-        # login(request, user)\n-        refresh = RefreshToken.for_user(user)\n-        user_obj = CustomUserSerializer(user,context={'request': request})\n-        return Response({\n-            'access': str(refresh.access_token),\n-            'refresh': str(refresh),\n-            'user': user_obj.data,\n-            'message': 'Login successful',\n-        }, status=status.HTTP_200_OK)\n-\n-\n-def createAppleAccount(idinfo):\n-    email = idinfo.get('email')\n-    if not email:\n-        raise serializers.ValidationError('Email address not provided.')\n-    username = email.split('@')[0]\n-    first_name = idinfo.get('full_name',username)\n-    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n-    if user.exists():\n-        user = CustomUser.objects.get(Q(email = email) | Q(username = username))\n-    else:    \n-        user = CustomUser.objects.create(email = email,is_verified = True , first_name = first_name, username=username,role = 5,old_password_change_case = False,provider = 4)\n-    return user , True\n-   \n-\n-\n-from django.db.models import Q\n-from django.contrib.auth import authenticate, login\n-from django.views.decorators.csrf import csrf_exempt\n-from django.contrib.auth.models import Group, Permission\n-from django.http import HttpResponse\n-from django_filters.rest_framework import DjangoFilterBackend\n-\n-from rest_framework import status, viewsets\n-from rest_framework.views import APIView\n-from rest_framework.response import Response\n-from rest_framework.permissions import IsAuthenticated\n-from rest_framework.filters import SearchFilter, OrderingFilter\n-from rest_framework_simplejwt.authentication import JWTAuthentication\n-from rest_framework_simplejwt.tokens import RefreshToken,TokenError\n-from rest_framework_simplejwt.tokens import AccessToken\n-from rest_framework.exceptions import PermissionDenied\n-from rest_framework import generics\n-from rest_framework.decorators import action\n-\n-from drf_yasg import openapi\n-from drf_yasg.utils import swagger_auto_schema\n-\n-from .models import CustomUser\n-\n-from . import roles\n-from .roles import roles_data\n-\n-from accounts.serializers.custom_user_serializers import LoginSerializer\n-from accounts.serializers.custom_user_serializers import (\n-    CustomUserReadSerializer,CustomUserSerializer, GroupSerializer, \n-    PermissionSerializer,RoleSerializer,CustomUserReadLimitedSerializer,\n-    UserDetailsSerializer,CustomUserReadLimitedSerializer_1\n-    )\n-\n-from .custompermission import AccountPermission,AllUserDataPermission\n-from .pagination import PageNumberPagination\n-\n-from .google_virify import VerifyGoogleToken\n-from .apple_verify import VerifyAppleToken\n-\n-from django.core.cache import cache\n-from django.views.decorators.cache import cache_page\n-from django.utils.decorators import method_decorator\n-cache_time = 300 # 300 is 5 minute\n-from django.db.models import Q\n-from rest_framework import serializers\n-\n-class CustomUserSerializerViewSet(viewsets.ModelViewSet):\n-    queryset = CustomUser.objects.all()\n-    # permission_classes = [Account]\n-    serializer_class = CustomUserReadSerializer\n-    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n-    search_fields = ['id','email','username','first_name']\n-    ordering_fields = ['username','id']\n-    filterset_fields = {\n-        'email': ['exact', 'icontains'],\n-        'username': ['exact'],\n-        'is_active':['exact'],\n-    }\n-\n-    permission_classes = [AccountPermission]\n-    \n-    def get_serializer_class(self):\n-        if self.action in ['create', 'update', 'partial_update']:\n-            return CustomUserSerializer\n-        return super().get_serializer_class()\n-    \n-    def get_queryset(self):\n-        user = self.request.user\n-        queryset = CustomUser.objects.all().order_by('-id')\n-        \n-        if not user.is_authenticated:\n-            query = CustomUser.objects.none()\n-        elif user.role == roles.SUPER_ADMIN:\n-            query = queryset\n-        elif user.role == roles.ADMIN:\n-            query = queryset.filter(id=user.id, role=roles.ADMIN)\n-        else:\n-            query = queryset.filter(id=user.id, is_active=True)\n-        \n-        return query.order_by(\"-created_date\")\n-    \n-    \n-    \n-    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n-    def list(self, request, *args, **kwargs):\n-        queryset = self.filter_queryset(self.get_queryset())\n-        serializer = self.get_serializer(queryset, many=True)\n-        data = serializer.data\n-        return Response(data)\n-\n-    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n-    def retrieve(self, request, *args, **kwargs):\n-        return super().retrieve(request, *args, **kwargs)\n-\n-    def destroy(self, request, *args, **kwargs):\n-        instance = self.get_object()\n-\n-        if instance.is_active:\n-            # If the user is active, mark them as inactive\n-        \n-            instance.is_active = False\n-            instance.delete= \"delete\"\n-            instance.save()\n-            # Create a custom response\n-            response_data = {\n-                \"message\": \"User Account marked as inactive\"\n-            }\n-        else:\n-            # If the user is already inactive, return a custom error response\n-            response_data = {\n-                \"message\": \"User Account is already inactive\"\n-            }\n-\n-        # Return the custom response\n-        return Response(response_data)\n-    \n-    def create(self, request, *args, **kwargs):\n-        serializer = self.get_serializer(data=request.data)\n-        serializer.is_valid(raise_exception=True)\n-\n-        # Save the new object to the database\n-        self.perform_create(serializer)\n-\n-    \n-        response_data = {\n-            \"message\": \"Account created successfully\",\n-            \"data\": serializer.data\n-        }\n-\n-            # Return the custom response\n-        return Response(response_data, status=status.HTTP_201_CREATED)\n-    \n-class RoleViewSet(APIView):\n-    # authentication_classes = [JWTAuthentication]\n-    # permission_classes = [IsAuthenticated]  \n-    \n-    def get(self,request,format=None):\n-        serializer = RoleSerializer(data=roles_data,many=True)\n-        serializer.is_valid()\n-        serialized_data = serializer.data\n-    \n-        return Response({\"roles\": serialized_data},status=status.HTTP_200_OK)\n-\n-\n-class GroupViewSet(viewsets.ModelViewSet):\n-    queryset = Group.objects.all()\n-    serializer_class = GroupSerializer\n-    filter_backends = [SearchFilter]\n-    search_fields = ['name']\n-    authentication_classes = [JWTAuthentication]\n-    permission_classes = [IsAuthenticated]    \n-    def create(self, request, *args, **kwargs):\n-        serializer = self.get_serializer(data=request.data)\n-        serializer.is_valid(raise_exception=True)\n-\n-        # Save the new object to the database\n-        self.perform_create(serializer)\n-\n-        # Create a custom response\n-        response_data = {\n-            \"message\": \"Group created successfully\",\n-            \"data\": serializer.data\n-        }\n-\n-        # Return the custom response\n-        return Response(response_data, status=status.HTTP_201_CREATED)\n-    \n-    def update(self, request, *args, **kwargs):\n-        partial = kwargs.pop('partial', False)\n-        instance = self.get_object()\n-        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n-        serializer.is_valid(raise_exception=True)\n-\n-        # Save the updated object to the database\n-        self.perform_update(serializer)\n-\n-        # Create a custom response\n-        response_data = {\n-            \"message\": \"Group updated successfully\",\n-            \"data\": serializer.data\n-        }\n-\n-        # Return the custom response\n-        return Response(response_data)\n-    \n-    def destroy(self, request, *args, **kwargs):\n-        instance = self.get_object()\n-\n-        # Perform the default delete logic\n-        self.perform_destroy(instance)\n-\n-        # Create a custom response\n-        response_data = {\n-            \"message\": \"Group deleted successfully\"\n-        }\n-\n-        # Return the custom response\n-        return Response(response_data)\n-\n-    \n-class PermissionViewSet(viewsets.ModelViewSet):\n-    queryset = Permission.objects.all()\n-    serializer_class = PermissionSerializer\n-    filter_backends = [SearchFilter,OrderingFilter]\n-    search_fields = ['name','code_name','is_verified']\n-    ordering_fields = ['id','name']\n-\n-    authentication_classes = [JWTAuthentication]\n-    permission_classes = [IsAuthenticated]    \n-\n-class PermissionAllDelete(APIView):\n-    authentication_classes = [JWTAuthentication]\n-    permission_classes = [IsAuthenticated]  \n-    def get(self, request, format=None):\n-        object = Permission.objects.all().delete()\n-        return Response({'message': 'All permission delete successful'}, status=status.HTTP_200_OK)\n-\n-class CheckTokenExpireView(APIView): \n-    def get(self, request, format=None):\n-        # Get the token from the request headers or query parameters\n-        try:\n-            raw_token = request.META.get('HTTP_AUTHORIZATION', '').split(' ')[1]\n-        except:\n-            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-        try:\n-            # Verify the access token\n-            access_token = AccessToken(raw_token)\n-            access_token.verify()\n-\n-            # If the token is valid and not expired\n-            return Response({'valid': True}, status=status.HTTP_200_OK)\n-\n-        except TokenError:\n-            # If the token is expired or invalid\n-            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-# Create your views here.\n-class LoginView(APIView):\n-    @swagger_auto_schema(\n-        request_body=openapi.Schema(\n-            type=openapi.TYPE_OBJECT,\n-            properties={\n-                'email': openapi.Schema(type=openapi.TYPE_STRING),\n-                'password': openapi.Schema(type=openapi.TYPE_STRING),\n-            },\n-            required=['email', 'password']\n-        ),\n-        # responses={200: MyResponseSerializer},\n-        operation_summary=\"Login and get token\",\n-        operation_description=\"Login and get token\",\n-    )\n-    # @csrf_exempt\n-    def post(self, request):\n-        username_or_email = request.data.get('email')\n-        password = request.data.get('password')\n-\n-        # Authenticate the user using either username or email\n-        user = authenticate(request, username=username_or_email, password=password)\n-        if user is None:\n-            user = authenticate(request, email=username_or_email, password=password)\n-\n-        # If the user is authenticated, log them in and generate tokens\n-        if user is not None:\n-            if user.is_active == False:\n-                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n-            login(request, user)\n-            refresh = RefreshToken.for_user(user)\n-            refresh['remember_me'] = request.data.get('remember_me',False)\n-            user_obj = CustomUserReadSerializer(request.user,context={'request': request}) \n-            return Response({\n-                'access': str(refresh.access_token),\n-                'refresh': str(refresh),\n-                'user': user_obj.data,\n-                'message': 'Login successful',\n-            }, status=status.HTTP_200_OK)\n-\n-        # If the user is not authenticated, return an error message\n-        else:\n-            from django.db.models import Q\n-            user_obj = CustomUser.objects.filter(Q(username=username_or_email) | Q(email=username_or_email))\n-            if user_obj.exists():\n-                return Response({'error': 'Invalid password'}, status=status.HTTP_401_UNAUTHORIZED)\n-            else:\n-                return Response({'error': 'Invalid username/email'}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-\n-class userLimitedData(generics.ListAPIView):\n-    # authentication_classes = [JWTAuthentication]\n-    # permission_classes = [IsAuthenticated]\n-\n-\n-    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n-    search_fields = ['id','email','username','first_name','last_name','phone']\n-    ordering_fields = ['username','id']\n-    filterset_fields = {\n-        'email': ['exact', 'icontains'],\n-        'username': ['exact'],\n-        'role': ['exact'],\n-        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n-        'is_active':['exact'],\n-    }\n-    \n-    def get_queryset(self):\n-        users = CustomUser.objects.filter(role = roles.USER,is_active = True)\n-        return users\n-\n-    def get_serializer_class(self):\n-        return CustomUserReadLimitedSerializer\n-    \n-    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n-    def list(self, request, *args, **kwargs):\n-        return super().list(request, *args, **kwargs)\n-\n-\n-class AllUserData(generics.ListAPIView):\n-    authentication_classes = [JWTAuthentication]\n-    permission_classes = [IsAuthenticated,] #AllUserDataPermission\n-    pagination_class =  PageNumberPagination\n-\n-    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n-    search_fields = ['id','email','username','first_name','last_name','phone']\n-    ordering_fields = ['username','id']\n-    filterset_fields = {\n-        'email': ['exact', 'icontains'],\n-        'username': ['exact'],\n-        'role': ['exact'],\n-        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n-        'is_active':['exact'],\n-    }\n-    \n-    def get_queryset(self):\n-        users = CustomUser.objects.all().order_by('id')\n-        return users\n-\n-    def get_serializer_class(self):\n-        return CustomUserReadLimitedSerializer_1\n-    \n-    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n-    def list(self, request, *args, **kwargs):\n-        return super().list(request, *args, **kwargs)\n-\n-\n-class UserDetailsView(generics.RetrieveAPIView):\n-    queryset = CustomUser.objects.all()\n-    serializer_class = UserDetailsSerializer\n-    authentication_classes = [JWTAuthentication]\n-    lookup_field = \"username\"\n-    # permission_classes = [IsAuthenticated]\n-\n-\n-class GoogleLogin(APIView):\n-    @csrf_exempt\n-    def post(self, request):\n-    \n-        google_id_token = request.data.get('idToken',False)\n-\n-        if google_id_token == False:\n-            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n-     \n-        idinfo,is_verify = VerifyGoogleToken(google_id_token)\n-       \n-        if idinfo:\n-            user,success_user = createGoogleAccount(idinfo)\n-        else:\n-            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n-   \n-        # If the user is authenticated, log them in and generate tokens\n-        if success_user == True:\n-            if user.is_active == False:\n-                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n-            # login(request, user)\n-            refresh = RefreshToken.for_user(user)\n-            user_obj = CustomUserSerializer(user,context={'request': request}) \n-            return Response({\n-                'access': str(refresh.access_token),\n-                'refresh': str(refresh),\n-                'user': user_obj.data,\n-                'message': 'Login successful',\n-            }, status=status.HTTP_200_OK)\n-\n-        # If the user is not authenticated, return an error message\n-        else:\n-            return Response({'error': 'Google Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n-        \n-def createGoogleAccount(idinfo):\n-    email = idinfo.get('email')\n-    first_name = idinfo.get('name')\n-    last_name = idinfo.get('family_name')\n-    username = email.split('@')[0]\n-    image = idinfo.get('picture')\n-    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n-    if user.exists():\n-        user = user.first()\n     else:\n         user = CustomUser.objects.create(email = email , first_name = first_name , last_name = last_name, username=username,role = 5,old_password_change_case = False,provider = 2,is_verified = True)\n \n     return user,True\n"
                },
                {
                    "date": 1725344664236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -352,38 +352,34 @@\n \n class GoogleLogin(APIView):\n     @csrf_exempt\n     def post(self, request):\n-    \n+\n         google_id_token = request.data.get('idToken',False)\n \n         if google_id_token == False:\n             return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n-     \n+\n         idinfo,is_verify = VerifyGoogleToken(google_id_token)\n-       \n+\n         if idinfo:\n             user,success_user = createGoogleAccount(idinfo)\n         else:\n             return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n-   \n-        # If the user is authenticated, log them in and generate tokens\n-        if success_user == True:\n-            if user.is_active == False:\n-                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n-            # login(request, user)\n-            refresh = RefreshToken.for_user(user)\n-            user_obj = CustomUserSerializer(user,context={'request': request}) \n-            return Response({\n-                'access': str(refresh.access_token),\n-                'refresh': str(refresh),\n-                'user': user_obj.data,\n-                'message': 'Login successful',\n-            }, status=status.HTTP_200_OK)\n \n-        # If the user is not authenticated, return an error message\n-        else:\n+        if success_user != True:\n             return Response({'error': 'Google Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n+        if user.is_active == False:\n+            return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n+        # login(request, user)\n+        refresh = RefreshToken.for_user(user)\n+        user_obj = CustomUserSerializer(user,context={'request': request})\n+        return Response({\n+            'access': str(refresh.access_token),\n+            'refresh': str(refresh),\n+            'user': user_obj.data,\n+            'message': 'Login successful',\n+        }, status=status.HTTP_200_OK)\n         \n def createGoogleAccount(idinfo):\n     email = idinfo.get('email')\n     first_name = idinfo.get('name')\n"
                },
                {
                    "date": 1725344674801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,10 +330,9 @@\n         'is_active':['exact'],\n     }\n     \n     def get_queryset(self):\n-        users = CustomUser.objects.all().order_by('id')\n-        return users\n+        return CustomUser.objects.all().order_by('id')\n \n     def get_serializer_class(self):\n         return CustomUserReadLimitedSerializer_1\n     \n"
                },
                {
                    "date": 1725344739242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,10 +302,9 @@\n         'is_active':['exact'],\n     }\n     \n     def get_queryset(self):\n-        users = CustomUser.objects.filter(role = roles.USER,is_active = True)\n-        return users\n+        return CustomUser.objects.filter(role = roles.USER,is_active = True)\n \n     def get_serializer_class(self):\n         return CustomUserReadLimitedSerializer\n     \n"
                },
                {
                    "date": 1725344747101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,9 +211,9 @@\n \n class PermissionAllDelete(APIView):\n     authentication_classes = [JWTAuthentication]\n     permission_classes = [IsAuthenticated]  \n-    def get(self, request, format=None):\n+    def get(self, request, format=None):  # sourcery skip: avoid-builtin-shadow\n         object = Permission.objects.all().delete()\n         return Response({'message': 'All permission delete successful'}, status=status.HTTP_200_OK)\n \n class CheckTokenExpireView(APIView): \n"
                }
            ],
            "date": 1725344503184,
            "name": "Commit-0",
            "content": "from django.db.models import Q\nfrom django.contrib.auth import authenticate, login\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.contrib.auth.models import Group, Permission\nfrom django.http import HttpResponse\nfrom django_filters.rest_framework import DjangoFilterBackend\n\nfrom rest_framework import status, viewsets\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.filters import SearchFilter, OrderingFilter\nfrom rest_framework_simplejwt.authentication import JWTAuthentication\nfrom rest_framework_simplejwt.tokens import RefreshToken,TokenError\nfrom rest_framework_simplejwt.tokens import AccessToken\nfrom rest_framework.exceptions import PermissionDenied\nfrom rest_framework import generics\nfrom rest_framework.decorators import action\n\nfrom drf_yasg import openapi\nfrom drf_yasg.utils import swagger_auto_schema\n\nfrom .models import CustomUser\n\nfrom . import roles\nfrom .roles import roles_data\n\nfrom accounts.serializers.custom_user_serializers import LoginSerializer\nfrom accounts.serializers.custom_user_serializers import (\n    CustomUserReadSerializer,CustomUserSerializer, GroupSerializer, \n    PermissionSerializer,RoleSerializer,CustomUserReadLimitedSerializer,\n    UserDetailsSerializer,CustomUserReadLimitedSerializer_1\n    )\n\nfrom .custompermission import AccountPermission,AllUserDataPermission\nfrom .pagination import PageNumberPagination\n\nfrom .google_virify import VerifyGoogleToken\nfrom .apple_verify import VerifyAppleToken\n\nfrom django.core.cache import cache\nfrom django.views.decorators.cache import cache_page\nfrom django.utils.decorators import method_decorator\ncache_time = 300 # 300 is 5 minute\nfrom django.db.models import Q\nfrom rest_framework import serializers\n\nclass CustomUserSerializerViewSet(viewsets.ModelViewSet):\n    queryset = CustomUser.objects.all()\n    # permission_classes = [Account]\n    serializer_class = CustomUserReadSerializer\n    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n    search_fields = ['id','email','username','first_name']\n    ordering_fields = ['username','id']\n    filterset_fields = {\n        'email': ['exact', 'icontains'],\n        'username': ['exact'],\n        'role': ['exact'],\n\n        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n        'is_active':['exact'],\n    }\n\n    permission_classes = [AccountPermission]\n    \n    def get_serializer_class(self):\n        if self.action in ['create', 'update', 'partial_update']:\n            return CustomUserSerializer\n        return super().get_serializer_class()\n    \n    def get_queryset(self):\n        user = self.request.user\n        queryset = CustomUser.objects.all().order_by('-id')\n        \n        if not user.is_authenticated:\n            query = CustomUser.objects.none()\n        elif user.role == roles.SUPER_ADMIN:\n            query = queryset\n        elif user.role == roles.ADMIN:\n            query = queryset.filter(id=user.id, role=roles.ADMIN)\n        else:\n            query = queryset.filter(id=user.id, is_active=True)\n        \n        return query.order_by(\"-created_date\")\n    \n    \n    \n    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n    def list(self, request, *args, **kwargs):\n        queryset = self.filter_queryset(self.get_queryset())\n        serializer = self.get_serializer(queryset, many=True)\n        data = serializer.data\n        return Response(data)\n\n    # @method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n\n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n\n        if instance.is_active:\n            # If the user is active, mark them as inactive\n        \n            instance.is_active = False\n            instance.delete= \"delete\"\n            instance.save()\n            # Create a custom response\n            response_data = {\n                \"message\": \"User Account marked as inactive\"\n            }\n        else:\n            # If the user is already inactive, return a custom error response\n            response_data = {\n                \"message\": \"User Account is already inactive\"\n            }\n\n        # Return the custom response\n        return Response(response_data)\n    \n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n\n        # Save the new object to the database\n        self.perform_create(serializer)\n\n    \n        response_data = {\n            \"message\": \"Account created successfully\",\n            \"data\": serializer.data\n        }\n\n            # Return the custom response\n        return Response(response_data, status=status.HTTP_201_CREATED)\n    \nclass RoleViewSet(APIView):\n    # authentication_classes = [JWTAuthentication]\n    # permission_classes = [IsAuthenticated]  \n    \n    def get(self,request,format=None):\n        serializer = RoleSerializer(data=roles_data,many=True)\n        serializer.is_valid()\n        serialized_data = serializer.data\n    \n        return Response({\"roles\": serialized_data},status=status.HTTP_200_OK)\n\n\nclass GroupViewSet(viewsets.ModelViewSet):\n    queryset = Group.objects.all()\n    serializer_class = GroupSerializer\n    filter_backends = [SearchFilter]\n    search_fields = ['name']\n    authentication_classes = [JWTAuthentication]\n    permission_classes = [IsAuthenticated]    \n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n\n        # Save the new object to the database\n        self.perform_create(serializer)\n\n        # Create a custom response\n        response_data = {\n            \"message\": \"Group created successfully\",\n            \"data\": serializer.data\n        }\n\n        # Return the custom response\n        return Response(response_data, status=status.HTTP_201_CREATED)\n    \n    def update(self, request, *args, **kwargs):\n        partial = kwargs.pop('partial', False)\n        instance = self.get_object()\n        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n        serializer.is_valid(raise_exception=True)\n\n        # Save the updated object to the database\n        self.perform_update(serializer)\n\n        # Create a custom response\n        response_data = {\n            \"message\": \"Group updated successfully\",\n            \"data\": serializer.data\n        }\n\n        # Return the custom response\n        return Response(response_data)\n    \n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n\n        # Perform the default delete logic\n        self.perform_destroy(instance)\n\n        # Create a custom response\n        response_data = {\n            \"message\": \"Group deleted successfully\"\n        }\n\n        # Return the custom response\n        return Response(response_data)\n\n    \nclass PermissionViewSet(viewsets.ModelViewSet):\n    queryset = Permission.objects.all()\n    serializer_class = PermissionSerializer\n    filter_backends = [SearchFilter,OrderingFilter]\n    search_fields = ['name','code_name','is_verified']\n    ordering_fields = ['id','name']\n\n    authentication_classes = [JWTAuthentication]\n    permission_classes = [IsAuthenticated]    \n\nclass PermissionAllDelete(APIView):\n    authentication_classes = [JWTAuthentication]\n    permission_classes = [IsAuthenticated]  \n    def get(self, request, format=None):\n        object = Permission.objects.all().delete()\n        return Response({'message': 'All permission delete successful'}, status=status.HTTP_200_OK)\n\nclass CheckTokenExpireView(APIView): \n    def get(self, request, format=None):\n        # Get the token from the request headers or query parameters\n        try:\n            raw_token = request.META.get('HTTP_AUTHORIZATION', '').split(' ')[1]\n        except:\n            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n\n        try:\n            # Verify the access token\n            access_token = AccessToken(raw_token)\n            access_token.verify()\n\n            # If the token is valid and not expired\n            return Response({'valid': True}, status=status.HTTP_200_OK)\n\n        except TokenError:\n            # If the token is expired or invalid\n            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n\n# Create your views here.\nclass LoginView(APIView):\n    @swagger_auto_schema(\n        request_body=openapi.Schema(\n            type=openapi.TYPE_OBJECT,\n            properties={\n                'email': openapi.Schema(type=openapi.TYPE_STRING),\n                'password': openapi.Schema(type=openapi.TYPE_STRING),\n            },\n            required=['email', 'password']\n        ),\n        # responses={200: MyResponseSerializer},\n        operation_summary=\"Login and get token\",\n        operation_description=\"Login and get token\",\n    )\n    # @csrf_exempt\n    def post(self, request):\n        username_or_email = request.data.get('email')\n        password = request.data.get('password')\n\n        # Authenticate the user using either username or email\n        user = authenticate(request, username=username_or_email, password=password)\n        if user is None:\n            user = authenticate(request, email=username_or_email, password=password)\n\n        # If the user is authenticated, log them in and generate tokens\n        if user is not None:\n            if user.is_active == False:\n                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n            login(request, user)\n            refresh = RefreshToken.for_user(user)\n            refresh['remember_me'] = request.data.get('remember_me',False)\n            user_obj = CustomUserReadSerializer(request.user,context={'request': request}) \n            return Response({\n                'access': str(refresh.access_token),\n                'refresh': str(refresh),\n                'user': user_obj.data,\n                'message': 'Login successful',\n            }, status=status.HTTP_200_OK)\n\n        # If the user is not authenticated, return an error message\n        else:\n            from django.db.models import Q\n            user_obj = CustomUser.objects.filter(Q(username=username_or_email) | Q(email=username_or_email))\n            if user_obj.exists():\n                return Response({'error': 'Invalid password'}, status=status.HTTP_401_UNAUTHORIZED)\n            else:\n                return Response({'error': 'Invalid username/email'}, status=status.HTTP_401_UNAUTHORIZED)\n\n\nclass userLimitedData(generics.ListAPIView):\n    # authentication_classes = [JWTAuthentication]\n    # permission_classes = [IsAuthenticated]\n\n\n    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n    search_fields = ['id','email','username','first_name','last_name','phone']\n    ordering_fields = ['username','id']\n    filterset_fields = {\n        'email': ['exact', 'icontains'],\n        'username': ['exact'],\n        'role': ['exact'],\n        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n        'is_active':['exact'],\n    }\n    \n    def get_queryset(self):\n        users = CustomUser.objects.filter(role = roles.USER,is_active = True)\n        return users\n\n    def get_serializer_class(self):\n        return CustomUserReadLimitedSerializer\n    \n    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n\n\nclass AllUserData(generics.ListAPIView):\n    authentication_classes = [JWTAuthentication]\n    permission_classes = [IsAuthenticated,] #AllUserDataPermission\n    pagination_class =  PageNumberPagination\n\n    filter_backends = [SearchFilter,DjangoFilterBackend,OrderingFilter]\n    search_fields = ['id','email','username','first_name','last_name','phone']\n    ordering_fields = ['username','id']\n    filterset_fields = {\n        'email': ['exact', 'icontains'],\n        'username': ['exact'],\n        'role': ['exact'],\n        'created_date': ['date__gte', 'date__lte'],  # Date filtering\n        'is_active':['exact'],\n    }\n    \n    def get_queryset(self):\n        users = CustomUser.objects.all().order_by('id')\n        return users\n\n    def get_serializer_class(self):\n        return CustomUserReadLimitedSerializer_1\n    \n    #m@method_decorator(cache_page(cache_time,key_prefix=\"CustomUser\"))\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n\n\nclass UserDetailsView(generics.RetrieveAPIView):\n    queryset = CustomUser.objects.all()\n    serializer_class = UserDetailsSerializer\n    authentication_classes = [JWTAuthentication]\n    lookup_field = \"username\"\n    # permission_classes = [IsAuthenticated]\n\n\nclass GoogleLogin(APIView):\n    @csrf_exempt\n    def post(self, request):\n    \n        google_id_token = request.data.get('idToken',False)\n\n        if google_id_token == False:\n            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n     \n        idinfo,is_verify = VerifyGoogleToken(google_id_token)\n       \n        if idinfo:\n            user,success_user = createGoogleAccount(idinfo)\n        else:\n            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n   \n        # If the user is authenticated, log them in and generate tokens\n        if success_user == True:\n            if user.is_active == False:\n                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n            # login(request, user)\n            refresh = RefreshToken.for_user(user)\n            user_obj = CustomUserSerializer(user,context={'request': request}) \n            return Response({\n                'access': str(refresh.access_token),\n                'refresh': str(refresh),\n                'user': user_obj.data,\n                'message': 'Login successful',\n            }, status=status.HTTP_200_OK)\n\n        # If the user is not authenticated, return an error message\n        else:\n            return Response({'error': 'Google Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n        \ndef createGoogleAccount(idinfo):\n    email = idinfo.get('email')\n    first_name = idinfo.get('name')\n    last_name = idinfo.get('family_name')\n    username = email.split('@')[0]\n    image = idinfo.get('picture')\n    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n    if user.exists():\n        user = user.first()\n        return user,True\n    else:    \n        user = CustomUser.objects.create(email = email , first_name = first_name , last_name = last_name, username=username,role = 5,old_password_change_case = False,provider = 2,is_verified = True)\n        return user , True\n\nclass AppleLogin(APIView):\n    @csrf_exempt\n    def post(self, request):\n    \n        apple_token = request.data.get('idToken',False)\n        if apple_token == False:\n            return Response({'error': 'No ID token provided.'}, status=status.HTTP_400_BAD_REQUEST)\n        \n        idinfo,is_verify = VerifyAppleToken(apple_token)\n        print(idinfo)\n        if idinfo:\n            user,success_user = createAppleAccount(idinfo)\n        else:\n            return Response({'error': 'Invalid ID token.'}, status=status.HTTP_401_UNAUTHORIZED)\n   \n        # If the user is authenticated, log them in and generate tokens\n        if success_user == True:\n            if user.is_active == False:\n                return Response({'error': 'Your Account is inactive'}, status=status.HTTP_401_UNAUTHORIZED)\n            # login(request, user)\n            refresh = RefreshToken.for_user(user)\n            user_obj = CustomUserSerializer(user,context={'request': request}) \n            return Response({\n                'access': str(refresh.access_token),\n                'refresh': str(refresh),\n                'user': user_obj.data,\n                'message': 'Login successful',\n            }, status=status.HTTP_200_OK)\n\n        # If the user is not authenticated, return an error message\n        else:\n            return Response({'error': 'Apple Token Failed to verify'}, status=status.HTTP_401_UNAUTHORIZED)\n\n\ndef createAppleAccount(idinfo):\n    email = idinfo.get('email')\n    if not email:\n        raise serializers.ValidationError('Email address not provided.')\n    username = email.split('@')[0]\n    first_name = idinfo.get('full_name',username)\n    user = CustomUser.objects.filter(Q(email = email) | Q(username = username))\n    if user.exists():\n        user = CustomUser.objects.get(Q(email = email) | Q(username = username))\n    else:    \n        user = CustomUser.objects.create(email = email,is_verified = True , first_name = first_name, username=username,role = 5,old_password_change_case = False,provider = 4)\n    return user , True\n   \n\n\n"
        }
    ]
}